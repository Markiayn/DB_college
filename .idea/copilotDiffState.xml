<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/dto/request/AlbumUpdateRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/dto/request/AlbumUpdateRequest.java" />
              <option name="updatedContent" value="package ua.markiyan.sonara.dto.request;&#10;&#10;import jakarta.validation.constraints.Size;&#10;import java.time.LocalDate;&#10;&#10;public record AlbumUpdateRequest(&#10;        @Size(min = 1, max = 500) String title,&#10;        LocalDate releaseDate,&#10;        String coverUrl&#10;) {}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/dto/request/ArtistUpdateRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/dto/request/ArtistUpdateRequest.java" />
              <option name="updatedContent" value="package ua.markiyan.sonara.dto.request;&#10;&#10;import jakarta.validation.constraints.Max;&#10;import jakarta.validation.constraints.Min;&#10;import jakarta.validation.constraints.Size;&#10;&#10;public record ArtistUpdateRequest(&#10;        @Size(min = 2, max = 100) String name,&#10;        @Size(max = 80) String country,&#10;        @Min(1900) @Max(2026) Integer startYear,&#10;        @Size(min = 2, max = 2000) String bio&#10;) {}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/dto/request/TrackUpdateRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/dto/request/TrackUpdateRequest.java" />
              <option name="updatedContent" value="package ua.markiyan.sonara.dto.request;&#10;&#10;import jakarta.validation.constraints.Size;&#10;&#10;public record TrackUpdateRequest(&#10;        @Size(min = 1, max = 500) String title,&#10;        Integer durationSec,&#10;        Boolean explicitFlag,&#10;        String audioKey,&#10;        String audioUrl&#10;) {}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/dto/request/UserUpdateRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/dto/request/UserUpdateRequest.java" />
              <option name="updatedContent" value="package ua.markiyan.sonara.dto.request;&#10;&#10;import jakarta.validation.constraints.Email;&#10;import jakarta.validation.constraints.Size;&#10;&#10;public record UserUpdateRequest(&#10;        @Email String email,&#10;        @Size(min = 2, max = 100) String name,&#10;        @Size(max = 80) String country&#10;) {}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/repository/PlaylistRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/repository/PlaylistRepository.java" />
              <option name="updatedContent" value="package ua.markiyan.sonara.repository;&#10;&#10;import org.springframework.data.jpa.repository.JpaRepository;&#10;import ua.markiyan.sonara.entity.Playlist;&#10;&#10;import java.util.List;&#10;&#10;public interface PlaylistRepository extends JpaRepository&lt;Playlist, Long&gt; {&#10;    List&lt;Playlist&gt; findAllByUser_Id(Long userId);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/service/AlbumService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/service/AlbumService.java" />
              <option name="originalContent" value="package ua.markiyan.sonara.service;&#10;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import ua.markiyan.sonara.dto.request.AlbumRequest;&#10;import ua.markiyan.sonara.dto.request.ArtistAlbumRequest;&#10;import ua.markiyan.sonara.dto.response.AlbumResponse;&#10;import java.time.LocalDate;&#10;import java.util.List;&#10;&#10;public interface AlbumService {&#10;    AlbumResponse create(AlbumRequest request);&#10;    AlbumResponse get(Long id);&#10;    List&lt;AlbumResponse&gt; listByArtist(Long artistId);&#10;    AlbumResponse getUnderArtist(Long artistId, Long albumId);&#10;&#10;    AlbumResponse createUnderArtist(Long artistId, ArtistAlbumRequest req);&#10;&#10;    Page&lt;AlbumResponse&gt; search(String title, LocalDate releaseDate, Pageable pageable);&#10;}&#10;" />
              <option name="updatedContent" value="package ua.markiyan.sonara.service;&#13;&#10;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import ua.markiyan.sonara.dto.request.AlbumRequest;&#13;&#10;import ua.markiyan.sonara.dto.request.ArtistAlbumRequest;&#13;&#10;import ua.markiyan.sonara.dto.request.AlbumUpdateRequest;&#13;&#10;import ua.markiyan.sonara.dto.response.AlbumResponse;&#13;&#10;import java.time.LocalDate;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;public interface AlbumService {&#13;&#10;    AlbumResponse create(AlbumRequest request);&#13;&#10;    AlbumResponse get(Long id);&#13;&#10;    List&lt;AlbumResponse&gt; listByArtist(Long artistId);&#13;&#10;    AlbumResponse getUnderArtist(Long artistId, Long albumId);&#13;&#10;&#13;&#10;    AlbumResponse createUnderArtist(Long artistId, ArtistAlbumRequest req);&#13;&#10;&#13;&#10;    Page&lt;AlbumResponse&gt; search(String title, LocalDate releaseDate, Pageable pageable);&#13;&#10;&#13;&#10;    // updates&#13;&#10;    AlbumResponse update(Long id, AlbumUpdateRequest req);&#13;&#10;    void delete(Long id);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/service/ArtistService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/service/ArtistService.java" />
              <option name="originalContent" value="package ua.markiyan.sonara.service;&#10;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import ua.markiyan.sonara.dto.request.ArtistRequest;&#10;import ua.markiyan.sonara.dto.response.ArtistResponse;&#10;&#10;&#10;public interface ArtistService {&#10;    ArtistResponse create(ArtistRequest request);&#10;    ArtistResponse get(Long id);&#10;    Page&lt;ArtistResponse&gt; search(String name, String country, Pageable pageable);&#10;}&#10;" />
              <option name="updatedContent" value="package ua.markiyan.sonara.service;&#13;&#10;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import ua.markiyan.sonara.dto.request.ArtistRequest;&#13;&#10;import ua.markiyan.sonara.dto.request.ArtistUpdateRequest;&#13;&#10;import ua.markiyan.sonara.dto.response.ArtistResponse;&#13;&#10;&#13;&#10;&#13;&#10;public interface ArtistService {&#13;&#10;    ArtistResponse create(ArtistRequest request);&#13;&#10;    ArtistResponse get(Long id);&#13;&#10;    Page&lt;ArtistResponse&gt; search(String name, String country, Pageable pageable);&#13;&#10;&#13;&#10;    // updates&#13;&#10;    ArtistResponse update(Long id, ArtistUpdateRequest req);&#13;&#10;    void delete(Long id);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/service/TrackService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/service/TrackService.java" />
              <option name="originalContent" value="package ua.markiyan.sonara.service;&#10;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import ua.markiyan.sonara.dto.request.AlbumTrackRequest;&#10;import ua.markiyan.sonara.dto.request.TrackRequest;&#10;import ua.markiyan.sonara.dto.response.TrackResponse;&#10;import ua.markiyan.sonara.dto.request.ArtistAlbumTrackRequest;&#10;&#10;import java.util.List;&#10;&#10;public interface TrackService {&#10;    TrackResponse create(TrackRequest request);      // плоский варіант (із artistId/albumId у body)&#10;    TrackResponse create(Long albumId, AlbumTrackRequest request);&#10;    TrackResponse get(Long id);&#10;&#10;    // ДЛЯ /api/artists/{artistId}/albums/{albumId}/tracks...&#10;    TrackResponse createUnderAlbum(Long artistId, Long albumId, ArtistAlbumTrackRequest req);&#10;    List&lt;TrackResponse&gt; listByAlbumWithArtsit(Long artistId, Long albumId);&#10;    java.util.List&lt;TrackResponse&gt; listByAlbum(Long albumId);&#10;    TrackResponse getOne(Long artistId, Long albumId, Long trackId);&#10;&#10;    Page&lt;TrackResponse&gt; search(String title, Integer durationSec, Boolean explicitFlag, Pageable pageable);&#10;    Page&lt;TrackResponse&gt; searchInAlbum(Long albumId, String title, Integer durationSec, Boolean explicitFlag, Pageable pageable);&#10;}&#10;" />
              <option name="updatedContent" value="package ua.markiyan.sonara.service;&#13;&#10;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import ua.markiyan.sonara.dto.request.AlbumTrackRequest;&#13;&#10;import ua.markiyan.sonara.dto.request.TrackRequest;&#13;&#10;import ua.markiyan.sonara.dto.response.TrackResponse;&#13;&#10;import ua.markiyan.sonara.dto.request.ArtistAlbumTrackRequest;&#13;&#10;import ua.markiyan.sonara.dto.request.TrackUpdateRequest;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;public interface TrackService {&#13;&#10;    TrackResponse create(TrackRequest request);      // плоский варіант (із artistId/albumId у body)&#13;&#10;    TrackResponse create(Long albumId, AlbumTrackRequest request);&#13;&#10;    TrackResponse get(Long id);&#13;&#10;&#13;&#10;    // ДЛЯ /api/artists/{artistId}/albums/{albumId}/tracks...&#13;&#10;    TrackResponse createUnderAlbum(Long artistId, Long albumId, ArtistAlbumTrackRequest req);&#13;&#10;    List&lt;TrackResponse&gt; listByAlbumWithArtsit(Long artistId, Long albumId);&#13;&#10;    java.util.List&lt;TrackResponse&gt; listByAlbum(Long albumId);&#13;&#10;    TrackResponse getOne(Long artistId, Long albumId, Long trackId);&#13;&#10;&#13;&#10;    Page&lt;TrackResponse&gt; search(String title, Integer durationSec, Boolean explicitFlag, Pageable pageable);&#13;&#10;    Page&lt;TrackResponse&gt; searchInAlbum(Long albumId, String title, Integer durationSec, Boolean explicitFlag, Pageable pageable);&#13;&#10;&#13;&#10;    // updates&#13;&#10;    TrackResponse update(Long id, TrackUpdateRequest req);&#13;&#10;    void delete(Long id);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/service/UserService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/service/UserService.java" />
              <option name="originalContent" value="package ua.markiyan.sonara.service;&#10;&#10;import ua.markiyan.sonara.dto.request.UserRequest;&#10;import ua.markiyan.sonara.dto.response.UserResponse;&#10;&#10;public interface UserService {&#10;    UserResponse create(UserRequest request);&#10;    UserResponse get(Long id);&#10;}&#10;" />
              <option name="updatedContent" value="package ua.markiyan.sonara.service;&#13;&#10;&#13;&#10;import ua.markiyan.sonara.dto.request.UserRequest;&#13;&#10;import ua.markiyan.sonara.dto.request.UserUpdateRequest;&#13;&#10;import ua.markiyan.sonara.dto.response.UserResponse;&#13;&#10;&#13;&#10;public interface UserService {&#13;&#10;    UserResponse create(UserRequest request);&#13;&#10;    UserResponse get(Long id);&#13;&#10;&#13;&#10;    UserResponse update(Long id, UserUpdateRequest req);&#13;&#10;    void delete(Long id);&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/service/impl/AlbumServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/service/impl/AlbumServiceImpl.java" />
              <option name="originalContent" value="package ua.markiyan.sonara.service.impl;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;import ua.markiyan.sonara.dto.request.AlbumRequest;&#10;import ua.markiyan.sonara.dto.request.ArtistAlbumRequest;&#10;import ua.markiyan.sonara.dto.response.AlbumResponse;&#10;import ua.markiyan.sonara.entity.Album;&#10;import ua.markiyan.sonara.entity.Artist;&#10;import ua.markiyan.sonara.exception.NotFoundException;&#10;import ua.markiyan.sonara.mapper.AlbumMapper;&#10;import ua.markiyan.sonara.repository.AlbumRepository;&#10;import ua.markiyan.sonara.repository.ArtistRepository;&#10;import ua.markiyan.sonara.service.AlbumService;&#10;&#10;import java.util.List;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;public class AlbumServiceImpl implements AlbumService {&#10;&#10;    private final AlbumRepository albumRepo;&#10;    private final ArtistRepository artistRepo;&#10;&#10;    @Override&#10;    @Transactional&#10;    public AlbumResponse create(AlbumRequest req) {&#10;        Artist artist = artistRepo.findById(req.artistId())&#10;                .orElseThrow(() -&gt; new NotFoundException(&quot;Artist %d not found&quot;.formatted(req.artistId())));&#10;&#10;        if (albumRepo.existsByTitleIgnoreCaseAndArtist_Id(req.title(), req.artistId())) {&#10;            throw new IllegalArgumentException(&quot;Album with the same title already exists for this artist&quot;);&#10;        }&#10;&#10;        Album entity = AlbumMapper.toEntity(req, artist);&#10;        Album saved = albumRepo.save(entity);&#10;        return AlbumMapper.toResponse(saved);&#10;    }&#10;&#10;    @Override&#10;    @Transactional(readOnly = true)&#10;    public AlbumResponse get(Long id) {&#10;        Album album = albumRepo.findWithArtistById(id)&#10;                .orElseThrow(() -&gt; new NotFoundException(&quot;Album %d not found&quot;.formatted(id)));&#10;        return AlbumMapper.toResponse(album);&#10;    }&#10;&#10;    @Override&#10;    @Transactional(readOnly = true)&#10;    public List&lt;AlbumResponse&gt; listByArtist(Long artistId) {&#10;        if (!artistRepo.existsById(artistId)) {&#10;            throw new NotFoundException(&quot;Artist %d not found&quot;.formatted(artistId));&#10;        }&#10;        return albumRepo.findAllByArtist_Id(artistId)&#10;                .stream()&#10;                .map(AlbumMapper::toResponse)&#10;                .toList();&#10;    }&#10;&#10;    @Override&#10;    @Transactional(readOnly = true)&#10;    public AlbumResponse getUnderArtist(Long artistId, Long albumId) {&#10;        Album album = albumRepo.findByIdAndArtist_Id(albumId, artistId)&#10;                .orElseThrow(() -&gt; new NotFoundException(&#10;                        &quot;Album %d not found for artist %d&quot;.formatted(albumId, artistId)));&#10;        return AlbumMapper.toResponse(album);&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    public AlbumResponse createUnderArtist(Long artistId, ArtistAlbumRequest req) {&#10;        Artist artist = artistRepo.findById(artistId)&#10;                .orElseThrow(() -&gt; new NotFoundException(&quot;Artist %d not found&quot;.formatted(artistId)));&#10;&#10;        if (albumRepo.existsByTitleIgnoreCaseAndArtist_Id(req.title(), artistId)) {&#10;            throw new IllegalArgumentException(&quot;Album with the same title already exists for this artist&quot;);&#10;        }&#10;&#10;        Album album = AlbumMapper.toEntity(req, artist);&#10;        Album saved = albumRepo.save(album);&#10;        return AlbumMapper.toResponse(saved);&#10;    }&#10;&#10;    @Override&#10;    @Transactional(readOnly = true)&#10;    public org.springframework.data.domain.Page&lt;AlbumResponse&gt; search(String title,&#10;                                                                      java.time.LocalDate releaseDate,&#10;                                                                      org.springframework.data.domain.Pageable pageable) {&#10;        boolean hasTitle = title != null &amp;&amp; !title.isBlank();&#10;        boolean hasDate  = releaseDate != null;&#10;&#10;        if (hasTitle &amp;&amp; hasDate) {&#10;            return albumRepo&#10;                    .findByTitleContainingIgnoreCaseAndReleaseDate(title, releaseDate, pageable)&#10;                    .map(AlbumMapper::toResponse);&#10;        } else if (hasTitle) {&#10;            return albumRepo&#10;                    .findByTitleContainingIgnoreCase(title, pageable)&#10;                    .map(AlbumMapper::toResponse);&#10;        } else if (hasDate) {&#10;            return albumRepo&#10;                    .findByReleaseDate(releaseDate, pageable)&#10;                    .map(AlbumMapper::toResponse);&#10;        } else {&#10;            return albumRepo&#10;                    .findAll(pageable)&#10;                    .map(AlbumMapper::toResponse);&#10;        }&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package ua.markiyan.sonara.service.impl;&#13;&#10;&#13;&#10;import lombok.RequiredArgsConstructor;&#13;&#10;import org.springframework.stereotype.Service;&#13;&#10;import org.springframework.transaction.annotation.Transactional;&#13;&#10;import ua.markiyan.sonara.dto.request.AlbumRequest;&#13;&#10;import ua.markiyan.sonara.dto.request.ArtistAlbumRequest;&#13;&#10;import ua.markiyan.sonara.dto.request.AlbumUpdateRequest;&#13;&#10;import ua.markiyan.sonara.dto.response.AlbumResponse;&#13;&#10;import ua.markiyan.sonara.entity.Album;&#13;&#10;import ua.markiyan.sonara.entity.Artist;&#13;&#10;import ua.markiyan.sonara.exception.NotFoundException;&#13;&#10;import ua.markiyan.sonara.mapper.AlbumMapper;&#13;&#10;import ua.markiyan.sonara.repository.AlbumRepository;&#13;&#10;import ua.markiyan.sonara.repository.ArtistRepository;&#13;&#10;import ua.markiyan.sonara.service.AlbumService;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;@Service&#13;&#10;@RequiredArgsConstructor&#13;&#10;public class AlbumServiceImpl implements AlbumService {&#13;&#10;&#13;&#10;    private final AlbumRepository albumRepo;&#13;&#10;    private final ArtistRepository artistRepo;&#13;&#10;&#13;&#10;    @Override&#13;&#10;    @Transactional&#13;&#10;    public AlbumResponse create(AlbumRequest req) {&#13;&#10;        Artist artist = artistRepo.findById(req.artistId())&#13;&#10;                .orElseThrow(() -&gt; new NotFoundException(&quot;Artist %d not found&quot;.formatted(req.artistId())));&#13;&#10;&#13;&#10;        if (albumRepo.existsByTitleIgnoreCaseAndArtist_Id(req.title(), req.artistId())) {&#13;&#10;            throw new IllegalArgumentException(&quot;Album with the same title already exists for this artist&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        Album entity = AlbumMapper.toEntity(req, artist);&#13;&#10;        Album saved = albumRepo.save(entity);&#13;&#10;        return AlbumMapper.toResponse(saved);&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    @Transactional(readOnly = true)&#13;&#10;    public AlbumResponse get(Long id) {&#13;&#10;        Album album = albumRepo.findWithArtistById(id)&#13;&#10;                .orElseThrow(() -&gt; new NotFoundException(&quot;Album %d not found&quot;.formatted(id)));&#13;&#10;        return AlbumMapper.toResponse(album);&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    @Transactional(readOnly = true)&#13;&#10;    public List&lt;AlbumResponse&gt; listByArtist(Long artistId) {&#13;&#10;        if (!artistRepo.existsById(artistId)) {&#13;&#10;            throw new NotFoundException(&quot;Artist %d not found&quot;.formatted(artistId));&#13;&#10;        }&#13;&#10;        return albumRepo.findAllByArtist_Id(artistId)&#13;&#10;                .stream()&#13;&#10;                .map(AlbumMapper::toResponse)&#13;&#10;                .toList();&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    @Transactional(readOnly = true)&#13;&#10;    public AlbumResponse getUnderArtist(Long artistId, Long albumId) {&#13;&#10;        Album album = albumRepo.findByIdAndArtist_Id(albumId, artistId)&#13;&#10;                .orElseThrow(() -&gt; new NotFoundException(&#13;&#10;                        &quot;Album %d not found for artist %d&quot;.formatted(albumId, artistId)));&#13;&#10;        return AlbumMapper.toResponse(album);&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    @Transactional&#13;&#10;    public AlbumResponse createUnderArtist(Long artistId, ArtistAlbumRequest req) {&#13;&#10;        Artist artist = artistRepo.findById(artistId)&#13;&#10;                .orElseThrow(() -&gt; new NotFoundException(&quot;Artist %d not found&quot;.formatted(artistId)));&#13;&#10;&#13;&#10;        if (albumRepo.existsByTitleIgnoreCaseAndArtist_Id(req.title(), artistId)) {&#13;&#10;            throw new IllegalArgumentException(&quot;Album with the same title already exists for this artist&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        Album album = AlbumMapper.toEntity(req, artist);&#13;&#10;        Album saved = albumRepo.save(album);&#13;&#10;        return AlbumMapper.toResponse(saved);&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    @Transactional(readOnly = true)&#13;&#10;    public org.springframework.data.domain.Page&lt;AlbumResponse&gt; search(String title,&#13;&#10;                                                                      java.time.LocalDate releaseDate,&#13;&#10;                                                                      org.springframework.data.domain.Pageable pageable) {&#13;&#10;        boolean hasTitle = title != null &amp;&amp; !title.isBlank();&#13;&#10;        boolean hasDate  = releaseDate != null;&#13;&#10;&#13;&#10;        if (hasTitle &amp;&amp; hasDate) {&#13;&#10;            return albumRepo&#13;&#10;                    .findByTitleContainingIgnoreCaseAndReleaseDate(title, releaseDate, pageable)&#13;&#10;                    .map(AlbumMapper::toResponse);&#13;&#10;        } else if (hasTitle) {&#13;&#10;            return albumRepo&#13;&#10;                    .findByTitleContainingIgnoreCase(title, pageable)&#13;&#10;                    .map(AlbumMapper::toResponse);&#13;&#10;        } else if (hasDate) {&#13;&#10;            return albumRepo&#13;&#10;                    .findByReleaseDate(releaseDate, pageable)&#13;&#10;                    .map(AlbumMapper::toResponse);&#13;&#10;        } else {&#13;&#10;            return albumRepo&#13;&#10;                    .findAll(pageable)&#13;&#10;                    .map(AlbumMapper::toResponse);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    @Transactional&#13;&#10;    public AlbumResponse update(Long id, AlbumUpdateRequest req) {&#13;&#10;        Album a = albumRepo.findById(id)&#13;&#10;                .orElseThrow(() -&gt; new NotFoundException(&quot;Album %d not found&quot;.formatted(id)));&#13;&#10;&#13;&#10;        if (req.title() != null &amp;&amp; !req.title().isBlank()) a.setTitle(req.title());&#13;&#10;        if (req.releaseDate() != null) a.setReleaseDate(req.releaseDate());&#13;&#10;        if (req.coverUrl() != null) a.setCoverUrl(req.coverUrl());&#13;&#10;&#13;&#10;        Album saved = albumRepo.save(a);&#13;&#10;        return AlbumMapper.toResponse(saved);&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    @Transactional&#13;&#10;    public void delete(Long id) {&#13;&#10;        if (!albumRepo.existsById(id)) throw new NotFoundException(&quot;Album %d not found&quot;.formatted(id));&#13;&#10;        albumRepo.deleteById(id);&#13;&#10;    }&#13;&#10;&#13;&#10;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/service/impl/ArtistServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/sonara/src/main/java/ua/markiyan/sonara/service/impl/ArtistServiceImpl.java" />
              <option name="originalContent" value="package ua.markiyan.sonara.service.impl;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;import ua.markiyan.sonara.dto.request.ArtistRequest;&#10;import ua.markiyan.sonara.dto.response.ArtistResponse;&#10;import ua.markiyan.sonara.entity.Artist;&#10;import ua.markiyan.sonara.exception.NotFoundException;&#10;import ua.markiyan.sonara.mapper.ArtistMapper;&#10;import ua.markiyan.sonara.repository.ArtistRepository;&#10;import ua.markiyan.sonara.service.ArtistService;&#10;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;public class ArtistServiceImpl implements ArtistService {&#10;    private final ArtistRepository repo;&#10;&#10;&#10;    @Override&#10;    @Transactional&#10;    public ArtistResponse create(ArtistRequest req) {&#10;        if (repo.existsByNameIgnoreCase(req.name())) {&#10;            throw new IllegalArgumentException(&quot;Artist with the same name already exists&quot;);&#10;        }&#10;&#10;        // мапимо DTO в ентіті&#10;        Artist entity = ArtistMapper.toEntity(req);&#10;&#10;&#10;        Artist saved = repo.save(entity);&#10;        return ArtistMapper.toResponse(saved);&#10;    }&#10;&#10;    @Override&#10;    @Transactional(readOnly = true)&#10;    public ArtistResponse get(Long id) {&#10;        Artist u = repo.findById(id)&#10;                .orElseThrow(() -&gt; new NotFoundException(&quot;Artist %d not found&quot;.formatted(id)));&#10;        return ArtistMapper.toResponse(u);&#10;    }&#10;&#10;    @Transactional(readOnly = true)&#10;    public Page&lt;ArtistResponse&gt; search(String name, String country, Pageable pageable) {&#10;        String n = (name == null) ? &quot;&quot; : name.trim();&#10;        String c = (country == null) ? &quot;&quot; : country.trim();&#10;        return repo&#10;                .findByNameContainingIgnoreCaseAndCountryContainingIgnoreCase(n, c, pageable)&#10;                .map(ArtistMapper::toResponse);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package ua.markiyan.sonara.service.impl;&#13;&#10;&#13;&#10;import lombok.RequiredArgsConstructor;&#13;&#10;import org.springframework.data.domain.Page;&#13;&#10;import org.springframework.data.domain.Pageable;&#13;&#10;import org.springframework.stereotype.Service;&#13;&#10;import org.springframework.transaction.annotation.Transactional;&#13;&#10;import ua.markiyan.sonara.dto.request.ArtistRequest;&#13;&#10;import ua.markiyan.sonara.dto.request.ArtistUpdateRequest;&#13;&#10;import ua.markiyan.sonara.dto.response.ArtistResponse;&#13;&#10;import ua.markiyan.sonara.entity.Artist;&#13;&#10;import ua.markiyan.sonara.exception.NotFoundException;&#13;&#10;import ua.markiyan.sonara.mapper.ArtistMapper;&#13;&#10;import ua.markiyan.sonara.repository.ArtistRepository;&#13;&#10;import ua.markiyan.sonara.service.ArtistService;&#13;&#10;&#13;&#10;&#13;&#10;@Service&#13;&#10;@RequiredArgsConstructor&#13;&#10;public class ArtistServiceImpl implements ArtistService {&#13;&#10;    private final ArtistRepository repo;&#13;&#10;&#13;&#10;&#13;&#10;    @Override&#13;&#10;    @Transactional&#13;&#10;    public ArtistResponse create(ArtistRequest req) {&#13;&#10;        if (repo.existsByNameIgnoreCase(req.name())) {&#13;&#10;            throw new IllegalArgumentException(&quot;Artist with the same name already exists&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        // мапимо DTO в ентіті&#13;&#10;        Artist entity = ArtistMapper.toEntity(req);&#13;&#10;&#13;&#10;&#13;&#10;        Artist saved = repo.save(entity);&#13;&#10;        return ArtistMapper.toResponse(saved);&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    @Transactional(readOnly = true)&#13;&#10;    public ArtistResponse get(Long id) {&#13;&#10;        Artist u = repo.findById(id)&#13;&#10;                .orElseThrow(() -&gt; new NotFoundException(&quot;Artist %d not found&quot;.formatted(id)));&#13;&#10;        return ArtistMapper.toResponse(u);&#13;&#10;    }&#13;&#10;&#13;&#10;    @Transactional(readOnly = true)&#13;&#10;    public Page&lt;ArtistResponse&gt; search(String name, String country, Pageable pageable) {&#13;&#10;        String n = (name == null) ? &quot;&quot; : name.trim();&#13;&#10;        String c = (country == null) ? &quot;&quot; : country.trim();&#13;&#10;        return repo&#13;&#10;                .findByNameContainingIgnoreCaseAndCountryContainingIgnoreCase(n, c, pageable)&#13;&#10;                .map(ArtistMapper::toResponse);&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    @Transactional&#13;&#10;    public ArtistResponse update(Long id, ArtistUpdateRequest req) {&#13;&#10;        Artist a = repo.findById(id)&#13;&#10;                .orElseThrow(() -&gt; new NotFoundException(&quot;Artist %d not found&quot;.formatted(id)));&#13;&#10;&#13;&#10;        if (req.name() != null &amp;&amp; !req.name().isBlank()) a.setName(req.name());&#13;&#10;        if (req.country() != null) a.setCountry(req.country());&#13;&#10;        if (req.startYear() != null) a.setStartYear(req.startYear());&#13;&#10;        if (req.bio() != null) a.setBio(req.bio());&#13;&#10;&#13;&#10;        Artist saved = repo.save(a);&#13;&#10;        return ArtistMapper.toResponse(saved);&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    @Transactional&#13;&#10;    public void delete(Long id) {&#13;&#10;        if (!repo.existsById(id)) throw new NotFoundException(&quot;Artist %d not found&quot;.formatted(id));&#13;&#10;        repo.deleteById(id);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>